package com.example.online_bank.security.jwt.factory.impl;import com.example.online_bank.config.JwtConfig;import com.example.online_bank.enums.TokenType;import com.example.online_bank.security.jwt.factory.TokenFactory;import com.example.online_bank.security.jwt.service.SpringAuthenticationService;import com.example.online_bank.security.jwt.service.JwtService;import io.jsonwebtoken.Jwts;import lombok.RequiredArgsConstructor;import org.springframework.security.core.Authentication;import org.springframework.stereotype.Component;import java.time.Instant;import java.util.Date;import java.util.HashMap;import java.util.Map;@Component@RequiredArgsConstructorpublic class RefreshTokenFactory implements TokenFactory {    private final JwtConfig config;    private final JwtService jwtService;    private final SpringAuthenticationService springAuthenticationService;    private static final String TOKEN_TYPE_VALUE = TokenType.REFRESH.getValue();    private static final String AUTH_DETAILS_KEY = "uuid";    /**     * @param auth - Информация о пользователе     * @return Refresh токен     */    //TODO реализовать в будущем с помощью redis таблицу с удаленными/заблокированными токенами    @Override    public String createToken(TokenType type, Authentication auth) {        if (!supports(type)) {            throw new IllegalArgumentException("Unsupported token type: " + type);        }        Date issuedDate = new Date();        Date notBeforeDate = Date.from(Instant.now());        Date expiredAt = new Date(issuedDate.getTime() + config.getRefreshTokenLifetime().toMillis());        Map<String, Object> details = springAuthenticationService.getDetails(auth);        String subject = (String) details.get(AUTH_DETAILS_KEY);        Map<String, Object> claims = new HashMap<>();        claims.put(TOKEN_TYPE_VALUE, type);        String id = jwtService.createId();        return Jwts.builder()                .subject(subject)                .issuer(config.getIssuer())                .id(id)                .notBefore(notBeforeDate)                .expiration(expiredAt)                .signWith(config.getKey())                .audience().add(config.getAudience())                .and()                .claims(claims)                .compact();    }    /**     * @param supported     * @return     */    @Override    public boolean supports(TokenType supported) {        return supported.equals(TokenType.REFRESH);    }}